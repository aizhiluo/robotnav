<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>srcl_ctrl: planning: Graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">srcl_ctrl: planning
   </div>
   <div id="projectbrief">motion planning algorithms developed at SRCL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Graph </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h3>a. Design</h3>
<p>Graph is a type of data structure that can be used to represent pairwise relations between objects. In this library, a graph is modeled as a collection of vertices and edges. The relations between those concepts are shown as follows.</p>
<ul>
<li>Graph<ul>
<li>Vertex 1<ul>
<li>Edge 1_1</li>
<li>Edge 1_2</li>
<li>...</li>
</ul>
</li>
<li>Vertex 2<ul>
<li>Edge 2_1</li>
<li>Edge 2_2</li>
<li>...</li>
</ul>
</li>
<li>...</li>
<li>Vertex n<ul>
<li>Edge n_1</li>
<li>Edge n_2</li>
<li>...</li>
<li>Edge n_m</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A minimal implementation of Graph consists of a list of vertices, each of which has an unique ID and a list of edges. For path finding in the graph, we need to add extra attributes, such as edge cost in Edge and heuristics, flags in Vertex for A* search. These attributes are generic for all graphs.</p>
<p>In different contexts, we usually want to add non-generic attributes to the vertex so that it can be meaningful for the application. For example when we use a graph to represent a square grid, a square cell can be regarded as a vertex, and the connectivities of a cell with its neighbour cells can be represented as edges. In this case, a square cell (vertex) may have attributes such as its location in the grid and its occupancy type (cell filled with obstacle or not). Such attributes can be very different across different applications, thus they are not modeled directly in the "Vertex" data structure. Instead, the "additional information" is packed into a separate object (called a <b>Bundled Data Structure (BDS)</b> in this design) and we associate a bundled data structure with a vertex uniquely.</p>
<h3>b. Implementation</h3>
<p>There are 3 class templates defined: <b>Graph</b>, <b>Vertex</b>, <b>Edge</b>. The use of template enables us to associate different types of "BDS" to a vertex, without modifying the code of the aforementioned 3 classes. In other words, the Graph, Vertex and Edge all have a "type", which is determined by the type of BDS we want to associate with the vertex. With the current implementation, the BDS has to be defined as a class or struct. <b>A user-defined BDS class/struct has to inherit from BDSBase class before we use them to construct a graph.</b> In the graph data structure, the vertex has the same ID with the BDS it's associated with. This is for solely for easy indexing to find one with the other.</p>
<p>Here is an example to use the templates.</p>
<p>I. We first define a BDS type we want to use for constructing the graph.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BDSExample: <span class="keyword">public</span> BDSBase&lt;BDSExample&gt;</div>
<div class="line">{</div>
<div class="line">    BDSExample(uint64_t <span class="keywordtype">id</span>):</div>
<div class="line">        BDSBase&lt;BDSExample&gt;(id){};</div>
<div class="line">    ~BDSExample(){};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// simplest implementation of the function</span></div>
<div class="line">    <span class="keywordtype">double</span> GetHeuristic(<span class="keyword">const</span> BDSExample&amp; other_struct)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> 0.0;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>II. Then we can create a few objects of class BDSExample</p>
<div class="fragment"><div class="line">std::vector&lt;BDSExample*&gt; nodes;</div>
<div class="line"></div>
<div class="line"><span class="comment">// create nodes to be bundled with the graph vertices</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 9; i++) {</div>
<div class="line">    nodes.push_back(<span class="keyword">new</span> BDSExample(i));</div>
</div><!-- fragment --><p>III. Now use those nodes to construct a graph. Note that the graph is of type BDSExample in this example.</p>
<div class="fragment"><div class="line"><span class="comment">// create a graph</span></div>
<div class="line">Graph&lt;BDSExample&gt; graph;</div>
<div class="line"></div>
<div class="line"><span class="comment">// the reference is used to access the bundled data structure in a vertex,</span></div>
<div class="line"><span class="comment">//  so you need to pass in an object instead of a pointer</span></div>
<div class="line">graph.AddEdge(*(nodes[0]), *(nodes[1]), 1.0);</div>
<div class="line">graph.AddEdge(*(nodes[0]), *(nodes[2]), 1.5);</div>
<div class="line">graph.AddEdge(*(nodes[1]), *(nodes[2]), 2.0);</div>
<div class="line">graph.AddEdge(*(nodes[2]), *(nodes[3]), 2.5);</div>
</div><!-- fragment --><p>IV. Now you've got a graph. You can print all edges of this graph in the following way</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> all_edges = graph.GetGraphEdges();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> e : all_edges)</div>
<div class="line">    e.PrintEdge();</div>
</div><!-- fragment --><p>You will get the output</p>
<div class="fragment"><div class="line">Edge: start - 0 , end - 1 , cost - 1</div>
<div class="line">Edge: start - 0 , end - 2 , cost - 1.5</div>
<div class="line">Edge: start - 1 , end - 2 , cost - 2</div>
<div class="line">Edge: start - 2 , end - 3 , cost - 2.5</div>
</div><!-- fragment --><h3>c. Memory Management</h3>
<p>When a Graph object goes out of scope, its destructor function will recycle memory allocated for this its vertices and edges. However, <b>the graph doesn't recycle memory allocated for the bundled data structure that each vertex is associated with</b>. In the square grid example, the graph doesn't assume the square grid also becomes useless when the graph itself is destructed. The <b>square grid</b> should be responsible for recycling the memory allocated for its square cells when it becomes of no use. Thus in the above simple example, we will need to do the following operation to free the memory at the end.</p>
<div class="fragment"><div class="line"><span class="comment">// delete objects of BDSExample</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; e : nodes)</div>
<div class="line">        <span class="keyword">delete</span> e;</div>
</div><!-- fragment --><h3>d. Notes on Graph</h3>
<ul>
<li>You may have noticed that when constructing a graph, you don't need to explicitly create objects of "Vertex". By calling member function <b>AddEdge(src_node, dst_node, cost)</b> of the graph, vertices are created and associated with the according BDS internally.</li>
<li>There are two views of the graph data structure. When constructing the graph (bottom-up view), the BDSs are manipulated directly and vertices are handled implicitly. When using the graph (top-down view) for path search, vertices are the the entities you're directly interacting with and the BDSs they associate with are probably of less interest. Of course, you can access one from the other easily using their common ID.</li>
<li>A* performs search on Vertex objects, so the A* algorithm also has a "type". In this implementation, A* search is provided as a member function of Graph. So you don't need to explicitly declare and initialize an A* instance. You can simply perform search on a graph by calling the search function packed in the graph.</li>
<li>An detailed example of using the graph for path search can be found in "apps/example.cpp". The work flow is shown as follows.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// create a graph from square grid</span></div>
<div class="line">Graph&lt;SquareCell&gt;* graph = GraphBuilder::BuildFromSquareGrid(grid,<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// specify search start and finish vertex</span></div>
<div class="line">Vertex&lt;SquareCell&gt;* start_vertex = graph-&gt;GetVertexFromID(0);</div>
<div class="line">Vertex&lt;SquareCell&gt;* finish_vertex = graph-&gt;GetVertexFromID(1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform A* search and get a vector of Vertics as the search result</span></div>
<div class="line">std::vector&lt;Vertex&lt;SquareCell&gt;*&gt; path = graph-&gt;AStarSearch(start_vertex,finish_vertex);</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 15 2016 17:30:51 for srcl_ctrl: planning by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
